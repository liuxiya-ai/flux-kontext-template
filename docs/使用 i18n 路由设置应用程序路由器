使用 i18n 路由设置应用程序路由器
为了为您的应用支持的每种语言使用唯一的路径名，可用于处理以下路由设置：next-intl

基于前缀的路由（例如/en/about)
基于域的路由（例如en.example.com/about)
无论哪种情况，都通过使用可用于提供不同语言内容的顶级动态段与 App Router 集成。next-intl[locale]

开始
如果您尚未这样做，请创建一个使用 App Router 的Next.js应用并运行：

npm install next-intl

现在，我们将创建以下文件结构：

├── messages
│   ├── en.json
│   └── ...
├── next.config.ts
└── src
    ├── i18n
    │   ├── routing.ts
    │   ├── navigation.ts
    │   └── request.ts
    ├── middleware.ts
    └── app
        └── [locale]
            ├── layout.tsx
            └── page.tsx

如果要将现有应用迁移到 ，则通常会在设置过程中将现有页面移动到文件夹中。next-intl[locale]

让我们设置文件：

messages/en.json
消息表示每种语言可用的翻译，可以在本地提供或从远程数据源加载。

最简单的选项是在本地项目文件夹中添加 JSON 文件：

消息/en.json
{
  "HomePage": {
    "title": "Hello world!",
    "about": "Go to the about page"
  }
}

next.config.ts
现在，设置一个插件，该插件创建一个别名，以提供特定于请求的 i18n 配置，例如您向服务器组件发送的消息——在以下步骤中将详细介绍这一点。

next.config.ts
import {NextConfig} from 'next';
import createNextIntlPlugin from 'next-intl/plugin';
 
const nextConfig: NextConfig = {};
 
const withNextIntl = createNextIntlPlugin();
export default withNextIntl(nextConfig);

src/i18n/routing.ts
我们将在两个地方与Next.js的路由集成：

中间件：协商语言环境并处理重定向和重写（例如 →//en)
导航 API：围绕Next.js导航 API 的轻量级包装器，例如<Link />
这使您能够使用诸如 的路径名，而语言前缀等 i18n 方面是在后台处理的。/about

为了在这两个地方之间共享配置，我们将设置：routing.ts

SRC/I18N/routing.ts
import {defineRouting} from 'next-intl/routing';
 
export const routing = defineRouting({
  // A list of all locales that are supported
  locales: ['en', 'de'],
 
  // Used when no locale matches
  defaultLocale: 'en'
});

根据您的要求，您可能希望稍后自定义路由配置，但让我们先完成设置。

src/i18n/navigation.ts
Once we have our routing configuration in place, we can use it to set up the navigation APIs.

src/i18n/navigation.ts
import {createNavigation} from 'next-intl/navigation';
import {routing} from './routing';
 
// Lightweight wrappers around Next.js' navigation
// APIs that consider the routing configuration
export const {Link, redirect, usePathname, useRouter, getPathname} =
  createNavigation(routing);

src/middleware.ts
Additionally, we can use our routing configuration to set up the middleware.

src/middleware.ts
import createMiddleware from 'next-intl/middleware';
import {routing} from './i18n/routing';
 
export default createMiddleware(routing);
 
export const config = {
  // Match all pathnames except for
  // - … if they start with `/api`, `/trpc`, `/_next` or `/_vercel`
  // - … the ones containing a dot (e.g. `favicon.ico`)
  matcher: '/((?!api|trpc|_next|_vercel|.*\\..*).*)'
};

src/i18n/request.ts
When using features from in Server Components, the relevant configuration is read from a central module that is located at by convention. This configuration is scoped to the current request and can be used to provide messages and other options based on the user’s locale.next-intli18n/request.ts

src/i18n/request.ts
import {getRequestConfig} from 'next-intl/server';
import {hasLocale} from 'next-intl';
import {routing} from './routing';
 
export default getRequestConfig(async ({requestLocale}) => {
  // Typically corresponds to the `[locale]` segment
  const requested = await requestLocale;
  const locale = hasLocale(routing.locales, requested)
    ? requested
    : routing.defaultLocale;
 
  return {
    locale,
    messages: (await import(`../../messages/${locale}.json`)).default
  };
});

src/app/[locale]/layout.tsx
The that was matched by the middleware is available via the param and can be used to configure the document language. Additionally, we can use this place to pass configuration from to Client Components via .localelocalei18n/request.tsNextIntlClientProvider

app/[locale]/layout.tsx
import {NextIntlClientProvider, hasLocale} from 'next-intl';
import {notFound} from 'next/navigation';
import {routing} from '@/i18n/routing';
 
export default async function LocaleLayout({
  children,
  params
}: {
  children: React.ReactNode;
  params: Promise<{locale: string}>;
}) {
  // Ensure that the incoming `locale` is valid
  const {locale} = await params;
  if (!hasLocale(routing.locales, locale)) {
    notFound();
  }
 
  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider>{children}</NextIntlClientProvider>
      </body>
    </html>
  );
}

src/app/[locale]/page.tsx
现在，您可以在组件中使用翻译和其他功能：next-intl

app/[locale]/page.tsx
import {useTranslations} from 'next-intl';
import {Link} from '@/i18n/navigation';
 
export default function HomePage() {
  const t = useTranslations('HomePage');
  return (
    <div>
      <h1>{t('title')}</h1>
      <Link href="/about">{t('about')}</Link>
    </div>
  );
}

对于异步组件，您可以改用 awaitable 函数：getTranslations

app/[locale]/page.tsx
import {getTranslations} from 'next-intl/server';
 
export default async function HomePage() {
  const t = await getTranslations('HomePage');
  return <h1>{t('title')}</h1>;
}

仅此而已！

如果您遇到问题，请查看 App Router 示例以探索有效的应用程序。

后续步骤：

使用指南：了解如何设置消息格式、日期和时间

路由：设置本地化路径名、基于域的路由和 更多

工作流程：与 TypeScript 等深度集成 工具

静态渲染
当将设置与 i18n 路由一起使用时，当前将选择在服务器组件中使用类似 API 时进入动态渲染。这是我们未来打算消除的限制，但作为权宜之计，提供了一个可用于启用静态渲染的临时 API。next-intluseTranslationsnext-intl

加generateStaticParams
由于我们对参数使用动态路由段，因此我们需要通过 generateStaticParams 将所有可能的值传递给Next.js，以便在构建时渲染路由。[locale]

根据您的需要，您可以添加到布局或页面：generateStaticParams

布局：为此布局中的所有页面启用静态渲染（例如app/[locale]/layout.tsx)
单个页面：为特定页面启用静态渲染（例如app/[locale]/page.tsx)
例：

import {routing} from '@/i18n/routing';
 
export function generateStaticParams() {
  return routing.locales.map((locale) => ({locale}));
}

添加到所有相关布局和页面setRequestLocale
next-intl提供了一个 API，可用于分发通过布局和页面接收的区域设置，以便在作为请求的一部分呈现的所有服务器组件中使用。params

app/[locale]/layout.tsx
import {setRequestLocale} from 'next-intl/server';
import {hasLocale} from 'next-intl';
import {notFound} from 'next/navigation';
import {routing} from '@/i18n/routing';
 
export default async function LocaleLayout({children, params}) {
  const {locale} = await params;
  if (!hasLocale(routing.locales, locale)) {
    notFound();
  }
 
  // Enable static rendering
  setRequestLocale(locale);
 
  return (
    // ...
  );
}

app/[locale]/page.tsx
import {use} from 'react';
import {setRequestLocale} from 'next-intl/server';
import {useTranslations} from 'next-intl';
 
export default function IndexPage({params}) {
  const {locale} = use(params);
 
  // Enable static rendering
  setRequestLocale(locale);
 
  // Once the request locale is set, you
  // can call hooks from `next-intl`
  const t = useTranslations('IndexPage');
 
  return (
    // ...
  );
}

请记住：

应验证您传递到的语言环境（例如，在您的根布局中）。setRequestLocale
您需要在要为其启用静态渲染的每个页面和每个布局中调用此函数Next.js因为可以独立渲染布局和页面。
setRequestLocale在调用 like 或 .next-intluseTranslationsgetMessages
在元数据中使用参数locale
除了页面的呈现之外，页面元数据还需要符合静态呈现的条件。

为此，您可以将从 Next.js via 收到的 转发到 next-intl 的可等待函数。localeparams

页面.tsx
import {getTranslations} from 'next-intl/server';
 
export async function generateMetadata({params}) {
  const {locale} = await params;
  const t = await getTranslations({locale, namespace: 'Metadata'});
 
  return {
    title: t('title')
  };
}